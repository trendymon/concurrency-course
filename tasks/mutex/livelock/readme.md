# Livelock

Изучите реализацию [`TrickyLock`](tricky_lock.hpp).

Реализация использует RMW (_read_-_modify_-_write_) операции [fetch_add](https://en.cppreference.com/w/cpp/atomic/atomic/fetch_add) и [fetch_sub](https://en.cppreference.com/w/cpp/atomic/atomic/fetch_sub). 

Нетрудно убедиться, что `TrickyLock` гарантирует взаимное исключение.

Но помимо взаимного исключения (*safety*, *никогда не случается ничего плохого*) спинлок должен гарантировать еще и прогресс (*liveness*, *однажды случится что-то хорошее*): если несколько потоков хотят захватить свободный спинлок, то один из них обязательно завершит свой вызов `.Lock()`.

В этой задаче вам нужно построить исполнение, в котором потоки бесконечно долго не могут захватить свободный `TrickyLock`.

## Планировщик

В этой задаче вы играете за планировщик, и должны делать это честно: в построенном вами бесконечном исполнении каждый из потоков должен выполнять бесконечно много шагов.

## Моделирование

В файле [`test.cpp`](test.cpp) вы найдете код, в котором потоки в цикле выполняют критические секции. Внутри этого цикла дана развертка методов `Lock` и `Unlock` `TrickyLock`-а, а также тело критической секции.

В коде используются неатомарные инкременты и декременты, поскольку пример построен на кооперативных файберах, которые вы уже встречали в задаче про дэдлоки.

Вы должны вставить в тело цикла переключения потоков (вызовы `Yield`) таким образом, чтобы потоки вошли в лайвлок. Разрешается вставлять только единичные вызовы `Yield`, писать новые циклы и условную логику нельзя.

Файл [`tricky_lock.hpp`](tricky_lock.hpp) менять не нужно, он дан лишь для ознакомления с алгоритмом.

## Yield

Напомним семантику вызова `Yield()` – передать управление планировщику и поместить текущий файбер (кооперативный поток) в хвост очереди на исполнение в планировщике.

## Тестирование

Если вы не лишены любопытства, то разберитесь, как устроено тестирование в этой задаче. Придумать тест в данном случае – интереснее, чем придумать решение самой задачи.
