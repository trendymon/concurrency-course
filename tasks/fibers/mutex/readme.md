# Мьютекс

## Пререквизиты

- [fibers/coroutine](/tasks/fibers/coroutine)
- [mutex/mutex](/tasks/mutex/mutex)
- [condvar/condvar](/tasks/condvar/condvar)

---

Реализуйте мьютекс ([`Mutex`](mtf/fibers/sync/mutex.hpp)) и условную переменную ([`CondVar`](mtf/fibers/sync/condvar.hpp)) для файберов.

Методы `Mutex::Lock` и `CondVar::Wait` должны блокировать только вызывающий их файбер, но не блокировать поток операционной системы.

## `FutexLike`

Реализация самого мьютекса и условной переменной не будет отличаться от реализации этих же примитивов для потоков, вы можете позаимствовать алгоритмы из уже решенных задач.

Но в этот раз у вас не будет фьютекса, для файберов его придется реализовать самостоятельно.

Реализуйте класс [`FutexLike<T>`](mtf/fibers/sync/futex.hpp) – атомик с дополнительными операциями `ParkIfEqual` и `WakeOne` / `WakeAll`.

Семантика `ParkIfEqual(T old)` – атомарно (относительно конкурирующих вызовов `WakeOne` / `WakeAll`) сравнить текущее значение атомика с `old` и в случае равенства запарковать текущий _файбер_ в очереди ожидания.

## Реализация

### `Suspend`

Вы увидите, что для реализации многопоточных файберов недостаточно иметь "системный вызов" `Suspend()`, вам потребуется расширить его сигнатуру.

Возможно, вам помогут идеи из корутин С++, концепт `Awaiter` с методом `await_suspend`. 
См. [C++ Coroutines: Understanding operator co_await](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)

#### Универсальность

Код, написанный вами в [`fibers/core`](mtf/fibers/core), должен быть универсален: в нем не должно быть знания про фьютексы и спинлоки, этот код должен пережить без изменений реализацию канала.

Можно легко понять, насколько хороший `Suspend` вы придумали: попробуйте выразить через него 
- Операцию `Result<T> Await(Future<T> f)`, которая позволяет файберу синхронно дождаться результата из фьючи без блокировки потока
- Синхронный `Socket`

### `SubmitContinuation`

Использовать метод `SubmitContinuation` у `StaticThreadPool` нельзя, гонку между остановкой файбера и планированием его возобновления нужно решить самостоятельно на уровне API `Suspend`.

### Аллокации

В реализации фьютекса не должно быть динамических аллокаций. Используйте [интрузивный список](https://gitlab.com/Lipovsky/wheels/-/blob/master/wheels/support/intrusive_list.hpp), узлы для него аллоцируйте на стеках файберов.

Сам `Suspend` так же не должен приводить к аллокациям. Использование `std::function` или аналогичного контейнера для type erasure – это тоже потенциальная скрытая аллокация.

### Разное

В классе `Fiber` не должно быть мьютексов / спинлоков / атомиков.

Убедитесь, что к пользователю, который инклудит заголовочный файл `mtf/fibers/sync/mutex.hpp`, не попадет объявление класса `Fiber`.

Для этого в реализации `FutexLike<T>` используйте `Suspend` и `FiberHandle`.
