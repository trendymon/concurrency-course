# Безопасный мьютекс

## Мотивирующий пример

Рассмотрим реализацию простого атомарного счетчика:

```cpp
class AtomicCounter {
 public:
  void Increment() {
    std::lock_guard guard(mutex_);
    // Мы в критической секции
    ++value_;
  }
  
  void GetValue() const {
    // Забыли захватить мьютекс );
    return value_;
  }
  
 private: 
  size_t value_{0};
  mutex mutex_;  // Защищает доступ к полю `value_`
};

```

В коде ошибка: разработчик забыл захватить мьютекс в методе `GetValue`.

Ошибка приводит к тому, что чтение переменной `value_` и изменение этой переменной могут происходить одновременно в разных потоках, без синхронизации друг с другом.
Такая ситуация имеет специальное название – _data race_. 
В С++ программа с data race считается некорректной (поведение такой программы не определено семантикой языка, это UB).

## Причина

По замыслу мьютекс `mutex_` в классе `AtomicCounter` должен защищать доступ к полю `value_`. 
Но этот замысел существует только в голове автора класса, а в коде этот замысел явно не выражен, компилятор не знает про связь полей `mutex_` и `value_`, а значит не может обнаружить ошибку.

## Решение – `Mutexed<T>`

Попробуем придумать более безопасное API для взаимного исключения, которое будет гарантировать, что к разделяемому объекту _невозможно_ обратиться не владея мьютексом.

Для этого свяжем объект, разделяемый между потоками, и мьютекс, который будет его защищать, с помощью класса – `Mutexed<T>`.

У класса `Mutexed` есть единственный метод `Lock`, который возвращает пользователю ссылку на защищаемый объект:

```cpp
Mutexed<std::vector<int>> ints; // vector<int> + mutex

{
  // Получаем эксклюзивную ссылку `ref` на вектор
  auto ref = ints.Lock();
  // Две вставки выполняются атомарно!
  ref->push_back(42);
  ref->push_back(43);
}  // ref разрушается -> мьютекс освобождается
```

Класс `Mutexed` гарантирует, что два потока не могут одновременно иметь в своем распоряжении ссылку на защищаемый объект: существование одной ссылки исключает существование других.

### Unique ref

Ссылка, возвращаемая методом `Mutexed<T>::Lock`, поддерживает два способа работы с защищаемым объектом:

#### Вызов методов

```cpp
Mutexed<std::vector<int>> shared_vector;

{
  auto ref = shared_vector.Lock();
  // Вызываем метод вектора через ->
  ref->push_back(7);
```

#### Примитивные типы

```cpp
Mutexed<int> shared_int{0};

{
  auto ref = shared_int.Lock();
  *ref = *ref + 1;
}
```

## Задача

Реализуйте [`Mutexed<T>`](mutexed.hpp).

### Замечания по реализации

Тип защищаемого объекта и набор методов `Mutexed`-у заранее неизвестен, он должен уметь оборачивать произвольный класс.

Изучите правила перегрузки оператора `->`: https://en.cppreference.com/w/cpp/language/operators

Попробуйте не вызывать методы `lock` и `unlock` у мьютекса голыми руками. Вместо этого используйте [`std::lock_guard`](https://en.cppreference.com/w/cpp/thread/lock_guard).

## `Mutexed` in the Wild

- [`Synchronized`](https://github.com/facebook/folly/blob/master/folly/docs/Synchronized.md) из библиотеки `facebook/folly`
- [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) из стандартной библиотеки языка [Rust](https://www.rust-lang.org/)

## Альтернативное решение

См. [Thread-safety analysis](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html) в компиляторе Clang.
