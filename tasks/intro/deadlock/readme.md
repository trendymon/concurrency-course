# Взаимная блокировка

В этой задаче вам нужно воспроизвести самый известный многопоточный баг – *взаимную блокировку* или *дэдлок* (*deadlock*).

Назовем *взаимной блокировкой* такое состояние исполнения, в котором ни один из потоков не может продолжить работу независимо от дальнейшего поведения планировщика, так как заблокировался в ожидании другого.

Дэдлок – терминальная конфигурация, выйти из него нельзя. В этом его отличие от *лайвлока* (*livelock*), из которого всегда можно выйти при удачном планировании потоков.

## Кооперативные файберы

Воспроизводить многопоточные баги сложно:
- Невозможно точно предсказать, когда планировщик операционной системы захочет снять текущий поток с процессора
- *Вытеснение* (*preemption*) происходит незаметно для исполняемого кода, он даже не узнает о том, что бы прерван

Чтобы преодолеть эти сложности, мы будем пользоваться специальными *кооперативными* потоками – [*файберами*](https://gitlab.com/Lipovsky/tinyfibers).

Планировщик файберов реализован в пространстве пользователя и детерминированно планирует файберы в одном потоке операционной системы.

Кооперативные файберы отдают управление планировщику только добровольно и явно:
- При вызове `self::Yield()` или `self::SleepFor(delay)`
- При вызове `mutex.Lock()` на [мьютексе](https://en.cppreference.com/w/cpp/thread/mutex), которым в данный момент владеет другой файбер

Планировщик не может остановить бегущий файбер и заменить его другим по собственной воле.

Семантика вызова `self::Yield()` – уступить управление следующему в очереди на исполнение файберу, а самому переместиться в конец очереди.

## Моделирование

Используя файберы, мы можем выстраивать детерминированные конкурентные исполнения, управляя переключениями с помощью вызовов `self::Yield()`.

Суть взаимной блокировки от замены потоков на файберы не меняется.

## Задача

Для начала разберитесь, как ведут себя файберы из [_Tiny Fibers_](https://gitlab.com/Lipovsky/tinyfibers).

Затем научитесь заводить файберы в дэдлок. Для этого заполните в [`tests.cpp`](tests.cpp) лямбды с комментарием
```cpp
// Your code goes here
```

Запускать новые файберы не нужно.

## Блокировки и драконы

Если вам понравилось управлять планировщиком и ломать многопоточный код, то непременно поиграйте в [Deadlock Empire](https://deadlockempire.github.io/)!
