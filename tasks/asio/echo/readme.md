# Эхо-сервер

*Programs must be written for people to read, and only incidentally for machines to execute.* – Harold Abelson, Gerald Jay Sussman

---

Эхо-сервер – это _HelloWorld_ мира сетевых приложений. Его задача – принимать
TCP-соединения клиентов, читать из них данные и отправлять их обратно. Поэтому и _эхо_.

Написать эхо-сервер можно по-разному...

## Потоки и синхронность

Посмотрим на простую [многопоточную реализацию](https://github.com/chriskohlhoff/asio/blob/master/asio/src/examples/cpp11/echo/blocking_tcp_echo_server.cpp) с использованием библиотеки [`asio`](https://github.com/chriskohlhoff/asio/).

В этой реализации на каждого клиента заводится отдельный поток, который в цикле читает из клиентского сокета очередную порцию данных и затем пишет ее обратно в сокет.

Чтение из сокета и запись в сокет в этом коде выполняются _синхронно_:
- Вызов `read_some` не вернет управление до тех пор, пока в сокете не появятся данные.
- Аналогично, вызов `write` не завершится, если клиент на другой стороне соединения долго не вычитывает данные.

## Асинхронность и коллбэки

Тот же эхо-сервер на `asio` можно переписать с использованием _асинхронного_ API, и обойтись при этом всего одним потоком.

В асинхронном решении исполнение подчиняется _циклу событий_ (_event loop_), в `asio` он выглядит так: `io_context.run()`. 

Цикл событий запускает служебные задачи (например, опрос событий на сокетах через `epoll_wait` и их обработку в неблокирующем режиме) и пользовательские _обработчики_ (_handlers_).

Пользовательские обработчики стартуют асинхронные операции, например, `socket.async_read_some(buffer, handler)`.

При вызове на сокете асинхронной операции `async_read_some` мы не блокируемся до момента появления данных (как в синхронном вызове), а _подписываемся_ на результат чтения – передаем в вызов _коллбэк_ (_callback_), после чего вызов `async_read_some` завершается _без ожидания_.

Коллбэк (обработчик) будет вызван на какой-то будущей итерации цикла событий, когда в `epoll_wait` соответствующий сокет станет доступным для чтения без блокировки.

### Цепочки

Обработку отдельного соединения в асинхронном решении можно представить как цепочку задач, в которой чередуются пользовательские обработчики и служебные задачи (`epoll_wait`, неблокирующие чтения/записи).

Разумеется, разные цепочки (конкурентные активности) разделяют общий `epoll_wait`, так что блокировка в исполнении происходит только на нем.

Все остальные действия происходят без блокировки, что позволяет упаковать их в единственный поток операционной системы.

## Трансформация кода

Можно заметить, что при перекладывании синхронного кода на асинхронные рельсы происходит следующая трансформация:

- Код разрывается в точках блокируюшего I/O на отдельные фрагменты-обработчики
- Локальные переменные со стека переезжают на кучу
- Сами конкрурентные активности переписываются в виде автомата, состояния которого соответствуют состоянию исполнения в точках блокирующих вызовов, а обработчики описывают переходы

В будущем мы увидим, как эту трансформацию можно выполнять не руками разработчика, а автоматически!

## Пул потоков

На `io_context` стоит смотреть не просто как на цикл событий, а как на пул потоков, который исполняет два типа задач:
- служебные: `epoll_wait`, неблокирующие чтения / записи в сокет
- пользовательские: обработчики асинхронных операций, которые, в свою очередь, стартуют новые асинхронные операции, т.е. порождают новые служебные задачи

При этом сам `io_context` не владеет потоками. Любой поток, который вызвал метод `run`, становится воркером этого пула.

## Reactor / Proactor

[The Proactor Design Pattern: Concurrency Without Threads](https://think-async.com/Asio/asio-1.18.1/doc/asio/overview/core/async.html) 

## Задача

Вам дана [асинхронная реализация](echo/server.cpp) эхо-сервера на `asio`. К сожалению, она не дописана и не проходит тесты. Ваша задача – довести её до рабочего состояния.

## Мораль

Эта задача должна побудить вас на размышления над тем, насколько по-разному выглядит синхронный код с потоками и асинхронный код на коллбэках, как по-разному организован в этих подходах поток управления.

Какой код легче читать и писать? Какая из реализаций эффективнее? Можно ли совместить сильные стороны обоих подходов?

## Материалы

* [Asio](https://github.com/chriskohlhoff/asio/)
* [Basic Asio Anatomy](http://think-async.com/Asio/asio-1.18.1/doc/asio/overview/core/basics.html)
* [Thinking Asynchronously: Designing Applications with Boost.Asio](https://www.youtube.com/watch?v=D-lTwGJRx0o), [слайды](http://cpp.mimuw.edu.pl/files/boost_vs_qt/asio/thinking_asynchronously.pdf)
