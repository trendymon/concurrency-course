# Замечания по использованию кондваров

- Не захватывайте и не освобождайте мьютексы голыми руками, используйте *scope-based resource management* – [`std::unique_lock`](https://en.cppreference.com/w/cpp/thread/unique_lock) и [`std::lock_guard`](https://en.cppreference.com/w/cpp/thread/lock_guard). Выбирайте `std::lock_guard`, если вам нужно просто захватить блокировку в данном скоупе и не нужно спать на условной переменной.

- Имя условной переменной должно отражать предикат, выполнения которого ждут потоки. Например, условную переменную, на которой метод `Take` в блокирующей очереди ждет появления элемента, разумно назвать `not_empty_` / `has_items_` / etc.

- Если потоки ждут выполнения разных предикатов на одном состоянии, то стоит развести их по разным условным переменным. Так вы сможете прицельно будить только нужные потоки.

- Не вызывайте `notify_all` там, где достаточно `notify_one`. С другой стороны, иногда `notify_all` наоборот может сэкономить вам лишние пробуждения. Поступайте разумно.

- Если для ожидания на условной переменной вы используете `cv.wait(lock, predicate)`, то обязаны знать, как выразить его через `cv.wait(lock)`, и почему он выражается именно так.

