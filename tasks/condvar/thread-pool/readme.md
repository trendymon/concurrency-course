# Static Thread Pool

В этой задаче мы построим базовый инфраструктурный компонент для параллельного исполнения задач – _пул потоков_ (_thread pool_).

Наш пул потоков будет _статическим_ – число потоков фиксируется при создании пула и не меняется до остановки пула.

Далее с потоками и параллельностью мы будем работать только через пулы.

## Схема работы

![Thread pool](images/thread_pool.png)

## Конструктор

```cpp
// Создаем пул из 4-х потоков
tp::StaticThreadPool pool{/*workers=*/4};
```

## `Submit`

Пул потоков исполняет [задачи](tp/task.hpp) – функции без аргументов и возвращаемого значения.

Запланировать задачу на исполнение в пуле можно с помощью метода `Submit`:

```cpp
tp::StaticThreadPool pool{4};

pool.Submit([]() {
  std::cout << "Hello from pool!" << std::endl;
});
```

Вызов `Submit` не дожидается завершения задачи, он лишь добавляет ее в очередь задач, после чего возвращает управление.

Метод `Submit` можно вызывать конкурентно из разных потоков.

### `Current`

Иногда хочется отправить новую задачу в пул прямо из бегущей задачи, т.е. из потока пула. 

Для этого нам пригодится свободная функция `tp::Current()`, которая возвращает
- указатель на текущий пул, если ее вызвали из потока-воркера,
- и `nullptr` в противном случае.

```cpp
tp::StaticThreadPool pool{4};

pool.Submit([]() {
  // Планируем задачу из задачи
  tp::Current()->Submit([]() {
    std::cout << "Works!" << std::endl;
  });
});
```

## Остановка

Пул должен быть остановлен до своего разрушения явно с помощью вызова метода `Join` либо `Shutdown`.

Пользователь пула должен вызвать только один из этих методов и только один раз, в противном случае – UB.

Опоздавшие `Submit`-ы (не успевшие запланировать задачу до закрытия очереди) будут игнорироваться пулом.

### `Join`

С помощью метода `Join` можно дождаться завершения работы в пуле и остановить потоки-воркеры:

```cpp
tp::StaticThreadPool pool{4};

for (size_t i = 0; i < 100500; ++i) {
  pool.Submit([]() {
     // ...
  });
}

// Ждем завершения 100500 задач
pool.Join();
```

С момента вызова `Join` пул работает до тех пор, пока в нем остается работа, т.е. пока счетчик запланированных, но еще не выполненных задач не опустился до нуля, после чего очередь задач закрывается и потоки-воркеры останавливаются.

Вызов `Join` возвращает управление, когда все потоки пула остановлены.

В частности, в следующем примере будут выполнены обе задачи:

```cpp
tp::StaticThreadPool pool{4};

pool.Submit([]() {
  // Спим 1 секунду
  // Не делайте так в пуле потоков!
  std::this_thread::sleep_for(1s);
  // К этому моменту уже вызван pool.Join()
  tp::Current()->Submit([]() {
    std::cout << "Works!" << std::endl;
  });
});

// На момент вызова Join вторая задача еще не запланирована,
// но она будет исполнена
pool.Join();
```

### `Shutdown`

Жесткая остановка – выбрасываем запланированные, но еще не запустившиеся задачи, после чего дожидаемся остановки потоков пула.

## Очередь

Для распределения задач между потоками пула будем использовать `UnboundedBlockingQueue` – общую блокирующую очередь неограниченной емкости.

### API

| Метод | Семантика |
|---|---|
| `bool Put(T value)` | Если очередь еще не закрыта (вызовом `Close` или `Cancel`), то положить в нее `value` и вернуть `true`, в противном случае вернуть `false`. |
| `std::optional<T> Take()` | Дождаться и извлечь элемент из головы очереди; если же очередь закрыта и пуста, то вернуть `std::nullopt`. |
| `void Close()` | Закрыть очередь для новых `Put`-ов. Уже добавленные в очередь элементы останутся доступными для извлечения. |
| `void Cancel()` | Закрыть очередь для новых `Put`-ов и выбросить все неизвлеченные элементы.

### Bounded vs Unbounded

Обратите внимание: пулу потоков нужна очередь именно неограниченной емкости.

Придумайте сценарий дедлока в пуле с очередью, которая блокирует поток-продьюсер при переполнении буфера.

## Замечания

### Возврат значения / ошибки, зависимости

- Метод `Submit` в пуле не предполагает никакого механизма возврата значения или ошибки из задачи.
  
- Пул потоков не дает возможности задать зависимости между планируемыми задачами.

И то, и другое, безусловно, полезно. Но в нашем пуле потоков ничего этого не будет, он останется максимально простым.

Требуемая функциональность (возврат результата, планирование задач с учетом завимостей) будет достигнута с помощью отдельных инструментов / абстракций, которые будут хорошо комбинироваться с пулом потоков, но при этом будут ортогональны ему.

### Unified Executors

Посмотрите на `static_thread_pool` из [A Unified Executors Proposal for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r14.html).

Можно увидеть, что:

- Пул потоков – это лишь один (хоть и важный) из компонентов сложной инфраструктуры экзекуторов.
- Пул потоков предоставляет разное API для планирования задач – `scheduler` и `executor`.

## Задание

1) Реализуйте [блокирующую очередь](tp/blocking_queue.hpp)
2) Реализуйте [статический пул потоков](tp/static_thread_pool.hpp)

Изучите [юнит-тесты](tests/unit) очереди и пула потоков чтобы разобраться с их поведением.

## Замечания по реализации

Вы можете добавлять в библиотеку `tp` новые файлы.

Добавлять новые публичные методы в очередь и пул нельзя.

### `Join`

Блокирующую остановку с ожиданием завершения задач можно реализовать разными способами, постарайтесь найти наиболее изящный вариант.

### Деструктор

Напишите `assert` в деструктор на случай забытого вызова `Join` / `Shutdown`.

### `thread_local`

Задача тестируется под файберами, поэтому реализовать функцию `tp::Current` через [`thread_local`](https://en.cppreference.com/w/cpp/keyword/thread_local) указатель на пул мы не можем.

Вместо `thread_local` мы будем использовать `twist::util::ThreadLocalPtr`:

```cpp
// ThreadLocalPtr<T> - замена thread_local T*
// - Для каждого потока хранит собственное значение указателя
// - Повторяет интерфейс указателя
// - Инициализируется nullptr-ом
ThreadLocalPtr<StaticThreadPool> pool;
```
